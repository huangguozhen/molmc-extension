var Arguments = require("./../arguments.js").Arguments,
  DataArgument = require("./../arguments.js").DataArgument,
  log = new (require('./../log.js').Log)('burstresponse'),
  GenericResponse = require('./generic.js').GenericResponse,
  ArgsResponse = require('./arguments.js'),
  genericRespHandler = require('./generic.js').genericRespHandler
require('./../setimmediate.js')

/**
 * Serving a burst response.
 *
 * @param {Array(Arguments)} cbArgsArr an array the arguments of calls
 * to a callback. We trust these contain no callbacks since they are
 * responses to the client.
 * @param {Message} reqMessage The message generated by BurstRequest.
 */
function BurstResponse (cbArgsArr, reqMessage) {
  this.cbArgsArr = cbArgsArr
  this.callbackId = reqMessage.callbackId
}

/**
 * Handle the response on the client side if it is of the correct
 * type.
 *
 * @param {Message} msg the raw message received by the server
 * @param {BurstRequest} request the request object that msg is a response
 * to.
 * @param {Function} doneCb Call this when you are done. It will be
 * called with no arguments on succes or an error object on error.
 * @return {Boolean} true if we handled it.
 */
var servedBurstMetrics = []
BurstResponse.maybeHandle = function (msg, request, doneCb) {
  if (msg.responseType != "BurstResponse") return false
  // Throw each response in the queue when the previous one is
  // finished. Before serving check if they are zombified by the
  // request.
  function arrInQueue(responses, err) {
    if (err) {
      doneCb(err)
      return
    }

    if (responses.length == 0) {
      doneCb()
      return
    }

    setImmediate(function () {
      var car = responses[0], cdr = responses.slice(1)

      if (!request.closed) {
        genericRespHandler(car, request, arrInQueue.bind(null, cdr))
        return
      }
      doneCb()
      // Allow the generic handler to throw at least some stuff in the
      // queue.
    })
  }

  // It is assumed that the ordering of data from different sources
  // and the size of the packets does not matter. Concat together
  // packets that have everything in common except the data field.
  function maybeConcatData(msgs) {
    var dataSources = {},
      /* eslint no-unused-vars: 0 */
      concatArg = msgs.forEach(function (m, i) {
        // Just keep this one as is
        if (!(m.args && DataArgument.canWrap(m.args[0]) && m.args.length == 1)) {
          dataSources[i] = m
          return
        }

        // Mask the data to make a source-unique token.
        var arg = m.args[0], backup = arg.data
        arg.data = null
        var token = JSON.stringify(arg)
        arg.data = backup
        var ret = dataSources[token]
        if (ret) {
          dataSources[token] = ret.concat(arg)
          return
        }

        dataSources[token] = new DataArgument(arg)
      })

    return Object.getOwnPropertyNames(dataSources).map(function (k) {
      var concatArg = dataSources[k]
      if (concatArg instanceof DataArgument) {
        return new ArgsResponse(
          new Arguments([concatArg.forSending()])).forSending()
      }

      return concatArg
    })
  }

  // Some debugging information
  if (0) {
    servedBurstMetrics.push({time: Date.now(), length: msg.cbArgsArr.length})
    var totalRequests = servedBurstMetrics.reduce(function (sum, m) {
      return sum + m.length
    }, 0)
    log.log("Burst summary:", {
      requestPerSec: totalRequests * 1000 /
        (Date.now() - servedBurstMetrics[0].time),
      totalRequests: totalRequests,
      currentRequests: msg.cbArgsArr.length
    })
  }
  arrInQueue(maybeConcatData(msg.cbArgsArr))

  return true
}
BurstResponse.prototype = Object.create(GenericResponse.prototype)

/**
 * Serialized response that also can be recognized as a response.
 *
 * @returns {Object} the object to be put through the API.
 */
BurstResponse.prototype.forSending = function () {
  return {responseType: "BurstResponse",
          cbArgsArr: this.cbArgsArr,
          callbackId: this.callbackId}
}
module.exports = BurstResponse
