var Arguments = require("./../arguments.js").Arguments,
    GenericRequest = require('./generic.js').GenericRequest,
    util = require("./../util"),
    ArgsResponse = require("./../responses.js").ArgsResponse,
    ErrResponse = require("./../responses.js").ErrResponse,
    AckResponse = require("./../responses.js").AckResponse,
    log = new (require('./../log.js').Log)('methodrequest');

function isNode () {
  if (typeof window === 'undefined') return true;

  // var backup = window,
  //   window_can_be_deleted = delete window;
  // window = backup; // Restoring from backup

  // return window_can_be_deleted;

  return false
}

/**
 * A request from the client to resolve a method call. Also handles
 * the response.
 *
 * @param {String} hostId The app id. Could be null if you dont intend
 * to send it.
 * @param {String} method The method to be called.
 * @param {Array|Arguments} args The real argument list or a wrapped
 * arguments object.
 * @param {Boolean} isReverser Wether this method request is supposed
 * to revert the side effects of a previous request.
 * @param {Boolean} noCallback true means that host should reply with
 * AckResponse.
 * @param {Function} withError Wrapper to handle errors.
 */
function MethodRequest (hostId, method, args, isReverser, noCallback, withError) {
  this.method = method;
  this.args = args instanceof Arguments ? args :
    new Arguments(args);
  this.hostId = hostId;
  this.isReverser = isReverser || false;
  this.noCallback = noCallback || false;
  this.withError = withError;
  // Node seems to display errors even if we don't throw them and it
  // gets really annoying
  if (!isNode()) {
    this.trace = (new Error()).stack;
  }

  if (this.args.forSending().filter(function (a) {
    return !!(a && a.isCallback);
  }).length > 1) {
    throw Error("We do not support more than one callback in arguments.");
  }
}

MethodRequest.prototype = Object.create(GenericRequest.prototype);

/**
 * Create a method request from a message. When a callback is provided
 * it will be used.
 *
 * @param {String} hostId The host to send the requset. Set this to
 * null if it's just for comparing or for invoking it's callback
 * (generally if you are on the host side.)
 * @param {Message} msg A message as generated by forSending()
 * @param {Function} respCb Raw send response callback.
 * @returns {MethodRequest} A method request.
 */
MethodRequest.fromMessage = function (hostId, msg, respCb) {
  var args = new Arguments(msg.args, respCb);
  return new MethodRequest(hostId, msg.method, args);
};

/**
 * If the message is a request to close a connection (reverser)
 *
 * @param {Message} msg A message generated by a MethodRequest.
 * @param {Array(HostConnection)} connections a list of open connections.
 * @param {Function} sendRespRaw Callback to send a raw message.
 * @param {Boolean} force This is a reverser even if id doesn't look
 * like it.
 * @returns {Boolean} True if we handled it.
 */
function handleReverser (msg, connections, hostApi) {
  if (!connections && !msg.isReverser) return false;
  var req = MethodRequest.fromMessage(null, msg),
      response = connections
        .map(function (c) {
          return c.tryClosing(req);
        }).reduce(function (a, b) {
          return a || b;
        }, false);

  // We won't get a response for args that don't raise a callback.
  if (msg.isReverser && !response) {
    console.warn(
      "You told me " + JSON.stringify(msg) +
        " was a reverser but i found nothing to reverse.");
    if (msg.noCallback) {
      // Trust the user knows what they are doing
      req.call(null, hostApi);
      return new ErrResponse("Tried to clean with " + msg.method + " but failed.",
                             "warning");
    }

    // There may be a callback waiting.
    return ArgsResponse.async(req, hostApi);
  }

  return response;
}

/**
 * Handle the request on the server. Try to run the method and
 * generate a *Response, serialize it and send it over the
 * sendRespApi. If the message doesn't seem valid, disregard it.
 *
 * @param {Message} msg A message generated by a MethodRequest.
 * @param {Array(HostConnection)} connections a list of open connections.
 * @param {hostApiObject} hostApi chrome API likae object where the
 * requrest method is based.
 * @param {Function} sendRespRaw Callback to send a raw message.
 * @returns {Boolean} True if we handled it.
 */
var messagesReceived = 0;
MethodRequest.maybeHandle = function (msg, connections, hostApi, sendRespRaw) {
  var _sendRespRaw = function (sendMsg) {
    if ((++messagesReceived) % 1000 == 0) {
      log.log("Sending 1000 messages");
    }

    if (sendMsg.responseType == "ErrResponse") {
      console.error(msg, "->", sendMsg);
    }

    sendRespRaw(sendMsg);
  };

  if (msg.requestType != "MethodRequest") {
    return false;
  }

  var resp = handleReverser(msg, connections, hostApi);
  if (resp) {
    resp.send(_sendRespRaw);
    return true;
  }

  sendRespRaw = sendRespRaw || function () {};
  var sendArgsAsResponse = function (varArgs) {
    var argsArr = [].slice.call(arguments),
        cbArgs = new Arguments(argsArr),
        argsResp = new ArgsResponse(cbArgs);

    // Internal api error
    if (chrome &&
        chrome.runtime &&
        chrome.runtime.lastError &&
        argsArr.length == 0) {
      new ErrResponse(chrome.runtime.lastError,
                      'chrome.runtime.lastError')
        .send(_sendRespRaw);
      return true;
    }

    // Everything went well.
    argsResp.send(_sendRespRaw);
  }, methodArgs = new Arguments(msg.args, sendArgsAsResponse),
      methodCb = util.path2callable(hostApi, msg.method);

  // Bad path received.
  if (!methodCb) {
    resp = new ErrResponse("Method " + msg.method + " not found.");
    resp.send(_sendRespRaw);
    return true;
  }

  try {
    // All went well
    methodCb.apply(null, methodArgs.forCalling());
    return true;
  } catch (e) {
    resp = new ErrResponse({message: "Error on calling " + msg.method + ":"
                            + e.message,
                            stack: e.stack},
                           'chrome.runtime.lastError');
    resp.send(_sendRespRaw);
    return true;
  }

  // We know this method wont bring up a callback.
  /* eslint no-unreachable: 0 */
  if (msg.noCallback) {
    new AckResponse().send(_sendRespRaw);
    return true;
  }
};

/**
 * @returns {Object} Serializable object to communicate with the server.
 */
MethodRequest.prototype.forSending = function () {
  var ret = {requestType: "MethodRequest",
             method: this.method,
             args: this.args.forSending(),
             noCallback: this.noCallback,
             isReverser: this.isReverser
            };
  return ret;

};

/**
 * Run this method request. This will not handle reversers.
 */
MethodRequest.prototype.call = function (sendResp, hostApi) {
  MethodRequest.maybeHandle(this.forSending(),
                            null,
                            hostApi,
                            sendResp || this.getCallback());
};

/**
 * Get the callback from the arguments. On the server this is a
 * function accepting a response type.
 *
 * @returns {Function} the callback or undefined.
 */
MethodRequest.prototype.getCallback = function () {
  return this.args.getCallback();
};

/**
 * Get the callback from the arguments. A usable one.
 *
 * @returns {Function} the callback or undefined.
 */
MethodRequest.prototype.realCallback = function () {
  var self = this, callback = self.args.getCallback();
  return function () {
    var args = new Arguments([].slice.call(arguments)),
        resp = new ArgsResponse(args);
    callback.call(null, resp.forSending());
  };
};

module.exports.MethodRequest = MethodRequest;
